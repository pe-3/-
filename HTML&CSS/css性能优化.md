[参考：https://juejin.cn/post/7077347573740077069](https://juejin.cn/post/7077347573740077069)
[toc]
# css性能优化

css 作为渲染的第一环节，影响着用户的第一体验

## css选择器渲染规则

css 选择器时从右向左匹配的

例子🌰
```css
.nav h3 a{font-size: 14px;}
```
选择器会先找到所有的a元素，然后向顶部遍历，直到找到匹配的路径

css选择器从右向左匹配在不匹配（非复杂选择器）时效率最高

## 内联首屏关键css

*首次有效绘制* (First Meaningful Paint, 简称FMP),指页面的首要内容出现在屏幕上的时间，内联首屏关键css能减少这一时间

内联首屏关键css指的是内联在html中的样式，第一时间展示给用户的样子，内联在HTML中的CSS可以更快的渲染

内联css不宜过多，应该把首要展示的样式内联进去，比如布局等关键样式

*初始拥塞窗口* 存在16.4kb的限制，所以内联样式不宜过多，放一些关键的即可

## 异步加载非首屏css

- css不会阻塞dom的解析，但会阻塞dom的渲染
- css不会阻塞js的下载，但会阻塞js的执行

由于css会阻塞dom的渲染，我们可以将首屏关键css内联后，其余样式都放在外部link，防止非首屏css阻塞页面的加载

## css异步加载方式

1. 第一种方式是动态创建,也就是创建link标签插入head的底部

```js
// 创建link标签
const myCss = document.createElement("link");
myCss.res = 'stylesheet';
myCss.href = 'myStyle.css';
// 插入header的最后内容
document.head.insertBefore(myCss,document.head.lastChild);
```

2. 第二种方式事将link标签的media值改为用户浏览器不匹配的媒体内容

```html
<!-- 对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被降低 -->
<!-- 这样设置之后就可以在不阻塞页面加载对情况下进行下载 -->
<link href = '' media='noexist' onload = "this.media = 'all'; ">
<!-- 在首屏加载完之后再将media设置为all或者screen，从而让浏览器开始解析css -->
```

3. 第三种方式是将ref标记为alternate 可选样式表
```html
<link ref ='alternate stylesheet' href ='1.css' onload = "this.ref = 'stylesheet'; ">
```

4. 第四种方式事用ref='preload'来异步加载css,as是必须的

```html
<link ref='preload' as='style' onload = "this.ref = 'stylesheet'">
```

## css文件压缩

通过webpack、gulp/grunt、rollup将css压缩为更小的从而加快浏览器的加载时间

## 减少过多的css层级嵌套

一般情况下，css的层级嵌套不要超过三层，过度的嵌套不但会使代码变得臃肿，还会使浏览器渲染的效率大大降低，造成性能浪费，影响渲染速度。而且这种写法，过渡依赖html文档结构，维护成本极高，如果要修改这种样式，可能就需要使用!important进行覆盖。尽量保持简单，不使用过于复杂的选择器

- 过多的嵌套会使得代码臃肿，同时样式会极其依赖html文档结构
- 这样会使的选择过多的遍历dom树，降低渲染性能
- 修改样式的时候由于过多嵌套导致权重过高，可能就需要!important 这种极其不优雅的方式

## 删除无用的css代码

无用的代码一般有两种：
1. 一种是在整个页面内都没有找到要渲染的元素
2. 一种是不同元素或者其他情况下的重复代码

## 慎用通配符选择器

通配符选择其的效率远远低于分组选择器的效率

```css
*{
    margin:0;
    padding:0;
}
```

```css
html, body, div, span, input, a, h1, p, form, ul, li{
    margin:0;
    padding:0;
}
```

## 小图片处理一般用雪碧图、字体图标、图片转base64

- cssSprite: 把所有icon小图片合成一张png图片，这样引用的时候只需要引用同一张照片的不同位置

- 字体图标：替换图标时只需要替换类名即可

- base64 转成这种格式，可以将图片直接放在代码中，加载更快，也可以防止相对路径的问题

## 避免使用@import 

@import 避免使用的原因

- @import 引用的css能在它所在的css文件被加载并且解析完之后，浏览器才知道引用 了这个文件，才去下载和解析，可能又会重新构建渲染树，这就导致浏览器无法并行下载css文件，更会影响浏览器的渲染性能。
- 多个@import会导致下载顺序紊乱

## 在ID选择器前嵌套其它选择器都是多余的

## 删除不必要的单位，零始终是零，在什么维度都是0，添加维度没有价值

## 优化回流与重绘

在网站修改有些样式时，浏览器检测到改变并重新渲染，其中有些操作会牵一发而动全身

- 合并对dom样式的修改，改为修改类名为提前写好的样式选择来达到修改样式的目的
- 避免使用table布局，table布局很容易重新布局
- css选择器从右向左匹配，避免选择器过于复杂

## dom离线处理，减少回流重绘次数

对离线的dom进行操作就不会引起页面发生重绘和回流，将display设置为none就可让这个元素不存在与dom树，就相当于将dom元素关进小黑屋，在里面到底发生了只有在dispaly设置为非none了之后页面才知道。

也可以将不在页面展示的dom放在 documentFragment 中创建一个dom片段

## 脱离文档流 
通过定位等让dom脱离文档流，使该元素成为渲染树中body的子元素，重排开销比较小，不会对其他节点造成过多影响

## css3 硬件（GPU)加速

使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

## 将节点设置为图层

图层能够阻⽌该节点的渲染⾏为影响别的节点。⽐如对于video标签来说，浏览器会⾃动将该节点变为图层。

## 减少使用昂贵的属性

在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等。
当然，并不是让大家不要使用这些属性，因为这些应该都是我们经常使用的属性。之所以提这一点，是让大家对此有一个了解。当有两种方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，如果每次都这样的选择，网站的性能会在不知不觉中得到一定的提升。
