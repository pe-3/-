[toc]
# 深浅拷贝
## 什么是浅拷贝？

- 只是将原对象栈中存的值或地址拷贝一份放到了新的对象上
- 修改新对象有可能会影响原对象

## 浅拷贝实现

```js

function shallowAssign(target){
    return Object.assign({}, target);
}

```

## 什么是深拷贝？

- 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

## 深拷贝的实现

### 1.序列化与反序列化

```js
const target = JSON.parse(JSON.stringify);
```
可以实现不是那么复杂的深拷贝
缺点

- 它依赖于JSON，所以不止此JSON以外的格式
- JSON只支持object，array，string，number，true，false，null
- 其他类型均不支持，比如undefined，函数，正则，Date等都会被忽略
- 对象不能是环状结构

### 2.递归克隆

#### 2.1 拷贝简单数据类型
简单数据类型保存的是值，修改不存在相互影响，所以直接返回即可
```js 
function DeepClone(target){
    return target;
}
```
#### 2.2 拷贝简单的对象

```js
function DeepClone(target){
    // 克隆简单的对象
    if(target instanceof Object){
        const dist = {};
        for(let key in target){
            dist[key] = DeepClone(target[key]);
        }        
        return dist;
    }

    return target;
}
```

#### 2.3 拷贝数组

```js
function DeepClone(target){
    // 克隆数组
    if(target instanceof Array){
        const dist = [];
        for(let index in target){
            dist[index] = DeepClone(target[index]);
        }
        return dist;
    }
    // 克隆简单的对象
    if(target instanceof Object){
        const dist = {};
        for(let key in target){
            dist[key] = DeepClone(target[key]);
        }        
        return dist;
    }

    return target;
}
```

#### 2.4 拷贝复杂的对象，函数
深克隆的目的是，引用属性不等，简单属性相同
可以通过call，或者apply实现函数克隆        
```js
function DeepClone(target){
    // 克隆复用函数
    const clone = funtion(source){
        for(let key in target){
            source[key] = DeepClone(target[key]);
        }
        return source
    }
    // 克隆函数
    if(target instanceof Function){
        const dist = function(...args){
            return target.call(this,args);
        }
        return clone(dist);
    }
    // 克隆数组
    if(target instanceof Array){
        const dist = [];
        return clone(dist);
    }
    // 克隆简单的对象
    if(target instanceof Object){
        const dist = {};
        return clone(dist);
    }

    return target;
}
```

#### 2.4 拷贝复杂的对象，正则
正则由两部分组成，正则的模式和正则的参数，分别在source和flags属性上
```js
const regexp = /a/ig
regexp.source a
regexo.flags ig
```
拿到这两部分即可创建一个新的zhengze
```js
function DeepClone(target){
    // 克隆复用函数
    const clone = function(source){
        for(let key in target){
            source[key] = DeepClone(target[key]);
        }
        return source
    }
    // 克隆正则
    if(target instanceof Regexp){
        return clone(new Regexp(target.source, target.flags));
    }
    // 克隆函数
    if(target instanceof Function){
        const dist = function(...args){
            return target.call(this,args);
        }
        return clone(dist);
    }
    // 克隆数组
    if(target instanceof Array){
        return clone([]);
    }
    // 克隆简单的对象
    if(target instanceof Object){
        return clone({});
    }

    return target;
}
```
#### 2.5 拷贝复杂的对象，日期
```js
function DeepClone(target){
    // 克隆复用函数
    const clone = function(source){
        for(let key in target){
            source[key] = DeepClone(target[key]);
        }
        return source
    }
    // 克隆日期
    if(target instanceof Date){
        return clone(new Date(source))
    }
    // 克隆正则
    if(target instanceof Regexp){
        return clone(new Regexp(target.source, target.flags));
    }
    // 克隆函数
    if(target instanceof Function){
        return clone(function(...args){
            return target.call(this,args);
        });
    }
    // 克隆数组
    if(target instanceof Array){
        return clone([]);
    }
    // 克隆简单的对象
    if(target instanceof Object){
        return clone({});
    }

    return target;
}
```

### 代码优化
#### 3.1 忽略原型上的属性
```js
function DeepClone(target){
    // 克隆复用函数
    const clone = function(source){
        for(let key in target){
            if(target.hanOwn)
            source[key] = DeepClone(target[key]);
        }
        return source;
    }
    //克隆日期
    if(target instanceof Date){
        return clone(new Date(source));
    }
    //克隆正则
    if(target instanceof Regexp){
        return clone(new Regexp(target.source, target.flags));
    }
    //克隆函数
    if(target instanceof Function){
        return clone(function(...args){
            return target.call(this,args);
        });
    }
    //克隆数组
    if(target instanceof Array){
        return clone([]);
    }
    //克隆简单的对象
    if(target instanceof Object){
        return clone({});
    }
    return target;
}
```

#### 3.2 环状对象克隆
用map把属性和属性值存起来，每次克隆之前都判断map中是否已经克隆过改属性，
克隆过直接返回map中的值
```js
function DeepClone(target, cache = new Map()){
    // 克隆复用函数
    const clone = function(source){
        for(let key in target){
            if(target.hanOwn)
            source[key] = DeepClone(target[key]);
        }
        return source;
    }
    //克隆日期
    if(target instanceof Date){
        return clone(new Date(source));
    }
    //克隆正则
    if(target instanceof Regexp){
        return clone(new Regexp(target.source, target.flags));
    }
    //克隆函数
    if(target instanceof Function){
        return clone(function(...args){
            return target.call(this,args);
        });
    }
    //克隆数组
    if(target instanceof Array){
        return clone([]);
    }
    //克隆简单的对象
    if(target instanceof Object){
        return clone({});
    }
    return target;
}
```